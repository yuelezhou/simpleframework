@startuml
== AbstractAutowireCapableBeanFactory.doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) ==
note left
该类的核心方法，创建Bean实例，填充属性
end note
==1/如果是单例则首先要清除缓存==
alt mbd.isSingleton
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory : this.factoryBeanInstanceCache.remove(beanName) -> BeanWrapper instanceWrapper
end
==2/实例化，将BeanDefinition转换成BeanWrapper==
alt instanceWrapper == null
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory : createBeanInstance(beanName, mbd, args) -> BeanWrapper instanceWrapper
AbstractAutowireCapableBeanFactory -> BeanWrapper : getWrappedInstance() -> Object bean
AbstractAutowireCapableBeanFactory -> BeanWrapper : getWrappedClass() -> Class<?> class
end
==3/MergedBeanDefinitionPostProcessor==
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory :applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)
note left
Allow post-processors to modify the merged bean definition
end note
==4/依赖处理==
alt (mbd.isSingleton() && this.allowCircularReferences &&isSingletonCurrentlyInCreation(beanName))
AbstractAutowireCapableBeanFactory -> DefaultSingletonBeanRegistry : addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean))
end
==5/属性填充==
AbstractAutowireCapableBeanFactory -> DefaultSingletonBeanRegistry : populateBean(beanName, mbd, instanceWrapper)
AbstractAutowireCapableBeanFactory -> DefaultSingletonBeanRegistry : initializeBean(beanName, exposedObject, mbd) ->Object
==6/循环依赖检查==
alt 同4 (mbd.isSingleton() && this.allowCircularReferences &&isSingletonCurrentlyInCreation(beanName))

end

==7/注册DisposableBean==
AbstractAutowireCapableBeanFactory -> AbstractBeanFactroy : registerDisposableBeanIfNecessary(beanName, bean, mbd);
==8/完成创建并返回==
return exposedObject
@enduml
